package jbotsim;


import java.awt.Color;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;


/**
 * @author JiaqiXu
 */
public abstract class Robot extends Node {
   
	
	SnapShot snap=null;
	Destination dest=null;
	boolean moving=false;
	Boolean collided = false;
	Boolean centerSensing = false; //Only the center of robot can sense its neighbors rather than the whole volue
	Volume volume=null;

	int bounds = 0;
	int light = 0; // numbers represent different color
	int faultyRound = 0; 

	ArrayList<Robot> sensedRobots = null;


	public abstract SnapShot look();
	public abstract Destination compute(SnapShot snap);
	public abstract void move(Destination a);

	/**
	 * In the current topology
	 * @return all the robots at the same location as this robot, exclude this robot
	 */
	public List<Robot> getRobotsOntheSameLocation()
	{
		List<Robot> robots = new ArrayList<Robot>();
		for(Robot robot : topo.robots)
		{
			if(robot !=this)
			{
			  if(robot.getLocation().equals( this.getLocation()))
				  robots.add(robot);
			}
		}
		return robots;	
	}

	/**
	 * 
	 * @return a point around one Of Visible vertexes
	 */
	public Point2D goToPointAroundVisibleVertexes()
	{
		int size = this.snap.visVertexesOfObstacles.size();
		Point2D vertex = this.snap.visVertexesOfObstacles.get((int)(Math.random()*size));
		double newDest_x = (int)(vertex.getX() + (Math.random()*40-20) );
		double newDest_y = (int)(vertex.getY() + (Math.random()*40-20) );
		Point2D newDest = new Point2D.Double(newDest_x, newDest_y);
		return newDest;
	}
	
	 /**
	  * 
	  * @return get all the visible vertexes of obstacles in topology
	  */
	public List<Point2D> getVisibleVertexesOfObstacles()
	{
		List<Point2D> visibleVertexes = new ArrayList<Point2D>();
		List<Segment> visibleSegments = this.getVisibleSegments();
		if(visibleSegments.isEmpty()) 
			return visibleVertexes;
		for(Obstacle o : topo.obstacles)
			for(Point2D p : o.vertexesOfObstacle)
			{
				for(Segment s: visibleSegments)
				{
					if(p.equals(s.left)||p.equals(s.right))
					{						
						if(!visibleVertexes.contains(p))
						visibleVertexes.add(p);
					}
				}
			}
		return visibleVertexes;
	}
	
	
	
	/**
	 * Given a segment
	 * @return visible part of this segment in obstacle environment
	 */
	public int call_num=0;
	public List<Segment> getVisibleSegment(Segment segment)
	{
	 //	System.out.println(call_num+"called function"+segment);
		call_num++;
		if(call_num > 20)
		{
			System.exit(0);
		}
		
		
	   List<Segment> results = new ArrayList<Segment>();
	   Segment presentVisSeg = segment;
	   Segment intermediate;
	   Point2D visPoint;
	   for(Obstacle o: this.topo.obstacles)
	   {
		   for(Segment s : o.segmentsOfObstalce)
		   {
			   if(s.isPointOnSegment(presentVisSeg.left) && s.isPointOnSegment(presentVisSeg.right))
				   continue;
			   
			   Segment r_left = new Segment(this.getLocation(),presentVisSeg.left);
			   Segment r_right= new Segment(this.getLocation(),presentVisSeg.right);
			   
			   //used for seeing if a point is inside the polygon which is generated by segment, r_left, r_right
			   double[] xpoints = {presentVisSeg.left.getX(),presentVisSeg.right.getX(), this.getLocation().getX()};
			   double[] ypoints = {presentVisSeg.left.getY(),presentVisSeg.right.getY(), this.getLocation().getY()};
			   Polygon2D polygon2d = new Polygon2D(xpoints, ypoints, xpoints.length);		
			   
			   if(r_left.HasIntersectionWithSegment(s)
						&&r_right.HasIntersectionWithSegment(s))//case 1: segment is blocked entirely by segment s
			   return results;
			   
			   if(r_left.HasIntersectionWithSegment(s)==true && r_right.HasIntersectionWithSegment(s) == false) //case 2.
			   {
				   if(r_left.AreInSameLine(s))//add on date 3.29
					   continue;

				  Point2D intersection = r_left.intersectionWithSegment(s); 
				  
				   //step 1 : check which point of s is contained in the polygon above
				  if(!intersection.equals(s.left)  && !intersection.equals(s.right)   ) // scenario 1 
				  {
					 if(polygon2d.IsPointContained(s.left))
					 {
				   //step 2 : get a new segment between two points below
					  intermediate = new Segment(this.getLocation(), s.left);
				   //step 3 : get the intersection point of new segment and segment s
					   visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
				   //step 4 : get the new visible segment that this robot can see at present
					  presentVisSeg = new Segment(visPoint, presentVisSeg.right);
				   //step 5 : continue checking if next s block this present visible segment 
					  continue;
					 }
					 else if (polygon2d.IsPointContained(s.right))
					 {
						  intermediate = new Segment(this.getLocation(), s.right);
					      visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
					      presentVisSeg = new Segment(visPoint, presentVisSeg.right);		     
						  continue;
					 }
				  }
				  else if (polygon2d.IsPointContained(s.left) || polygon2d.IsPointContained(s.right))
				  { //scenario 2
					  if(intersection.equals(s.left))
					  {
					//step 2 : get a new segment between two points below
					  intermediate = new Segment(this.getLocation(), s.right);
				   //step 3 : get the intersection point of new segment and segment s
					   visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
				   //step 4 : get the new visible segment that this robot can see at present
					  presentVisSeg = new Segment(visPoint, presentVisSeg.right);
				   //step 5 : continue checking if next s block this present visible segment 
					  continue;
					  }
					  else if (intersection.equals(s.right))
					  {
						  intermediate = new Segment(this.getLocation(), s.left);
					      visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
					      presentVisSeg = new Segment(visPoint, presentVisSeg.right);
						  continue;
					  }				  
				  } 
				  // for scenario 3 the presentVisSeg is unchanged		  				  
			   }
			   
			   if(r_left.HasIntersectionWithSegment(s)==false && r_right.HasIntersectionWithSegment(s)==true) 
			   {//case 3		
				   
				   if(r_right.AreInSameLine(s))//add on date 3.29
					   continue;
				   
				   Point2D intersection = r_right.intersectionWithSegment(s); 
				   //step 1 : check which point of s is contained in the polygon above
				  if(!intersection.equals(s.left ) && !intersection.equals(s.right)  ) // scenario 1 
				  {
					 if(polygon2d.IsPointContained(s.left))
					 {
					  intermediate = new Segment(this.getLocation(), s.left);
					  visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
					  presentVisSeg = new Segment(visPoint, presentVisSeg.left);
					  continue;
					 }
					 else if (polygon2d.IsPointContained(s.right))
					 {
						  intermediate = new Segment(this.getLocation(), s.right);
					      visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
					      presentVisSeg = new Segment(visPoint, presentVisSeg.left);
						  continue;
					 }
				  }
				  else if (polygon2d.IsPointContained(s.left) || polygon2d.IsPointContained(s.right))
				  { //scenario 2
					  if(intersection.equals(s.left))
					  {
					//step 2 : get a new segment between two points below
					  intermediate = new Segment(this.getLocation(), s.right);
				   //step 3 : get the intersection point of new segment and segment s
					   visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
				   //step 4 : get the new visible segment that this robot can see at present
					  presentVisSeg = new Segment(visPoint, presentVisSeg.left);
					
				   //step 5 : continue checking if next s block this present visible segment 
					  continue;
					  }
					  else if (intersection.equals(s.right))
					  {
						  intermediate = new Segment(this.getLocation(), s.left);
					      visPoint = intermediate.intersectionWithSegmentAsLine(presentVisSeg);
					      presentVisSeg = new Segment(visPoint, presentVisSeg.left);				    
						  continue;
					  }				  
				  } 
				  // for scenario 3 the presentVisSeg is unchanged		  		
			   }		   
			   
			   if(r_left.HasIntersectionWithSegment(s)==false && r_right.HasIntersectionWithSegment(s)==false
					   && polygon2d.IsPointContained(s.left) && polygon2d.IsPointContained(s.right))
				   //case 4
			   {
				   Segment intermediate1 = new Segment(this.getLocation(), s.left);
				   Segment intermediate2 = new Segment(this.getLocation(), s.right);
				   Point2D intersection1 = intermediate1.intersectionWithSegmentAsLine(presentVisSeg);
				   Point2D intersection2 = intermediate2.intersectionWithSegmentAsLine(presentVisSeg);
				 /*  if(intersection1.equals(intersection2))
				   {
					   continue;
				   }*/
				   Segment preVisSegment1;
				   Segment previsSegment2;
				   if(intersection1.distance(presentVisSeg.left) <= intersection2.distance(presentVisSeg.left))
				   {
					   preVisSegment1 = new Segment(intersection1, presentVisSeg.left);
					   previsSegment2 = new Segment(intersection2, presentVisSeg.right);
				   }
				   else {
					   preVisSegment1 = new Segment(intersection1, presentVisSeg.right);
					   previsSegment2 = new Segment(intersection2, presentVisSeg.left);
				}
				   List<Segment> part1 = getVisibleSegment(preVisSegment1);
				   List<Segment> part2 = getVisibleSegment(previsSegment2);
				   
				   if(!part1.isEmpty())
				   {
				    for(Segment x: part1)
				    {
				    	results.add(x);
				    }
				   }
				  
				   if(!part2.isEmpty())
				   {
				    for(Segment y : part2)
				    {
				    	results.add(y);
				    }
				   }
				    return results;		 	
			   }
		   }		   
	   }
	   
	   results.add(presentVisSeg);
		
	   return results;
	}
	
	
	/**
	 * Created by Jiaqi Xu
	 * @return all the visible segments in obstacles
	 */
	public List<Segment> getVisibleSegments()
	{ 
		List<Segment> visibleSegments = new ArrayList<Segment>();
		for(Obstacle o : this.topo.obstacles)
			for(Segment s: o.segmentsOfObstalce)//for each segment
			{
				call_num=0;
				List<Segment> visPart = getVisibleSegment(s);
				if(!visPart.isEmpty())
				{
					for(Segment segment : visPart)
					{
						visibleSegments.add(segment);
					}
				}
			}
		
		return visibleSegments;
	}
	
	// Created by Jiaqi Xu
	// return all the robots that this robot can see in the obstacle environment
	// in this topology
	public List<Robot> getVisibleRobots() {
		List<Robot> robots = new ArrayList<Robot>();
		boolean sign = false;
		double distance;

		for (Robot r : topo.robots) {
			if (r != this) {
				for (Obstacle o : this.topo.obstacles) {
					Segment segment = new Segment(this.getLocation(),r.getLocation());
					sign = o.intersectsWithSegment(segment);
					if (sign == true)
						break;
				}

				if (sign == false) {
					// ToFix
					distance = Math.sqrt((this.coords.getX() - r.coords.getX())
							* (this.coords.getX() - r.coords.getX())
							+ (this.coords.getY() - r.coords.getY())
							* (this.coords.getY() - r.coords.getY()));
					if (this.sensingRange >= distance) {
						robots.add(r);
					}
				}
			}
		}

		return robots;
	}
	
	@Override
	public void onPreClock() {
		super.onPreClock();
		snap=this.look();
	}

	@Override
	public void onClock() {
		super.onClock();
		dest=this.compute(snap);
		this.moving=true;
	}

	@Override
	public void onPostClock() {
		super.onPostClock();
		this.move(dest);
	}

	public double distance(Destination dest){
		double dist=0;
		if(dest instanceof Destination2D){
			dist=this.distance(((Destination2D)dest).dest);

		}
		return dist;
	}

	public void asynchMove(){
		this.moving = true;
		Random rd=new Random();

		if(rd.nextBoolean()==false){

			double scale = Math.random();

			double x= scale*(((Destination2D)dest).dest.getX()-this.getX());
			double y= scale*(((Destination2D)dest).dest.getY()-this.getY());

			Destination2D newDest;
			newDest = new Destination2D();
			newDest.dest=new Point2D.Double();
			newDest.dest.setLocation(this.getX()+x,this.getY()+y);

			Destination olddest=this.dest;
			this.dest=newDest;
			this.onPostClock();
			this.dest=olddest;

		}else{

			this.moving=false;
			this.onPostClock();
		}
	}

	//get sensed robots within the sensing range
	public ArrayList<Robot> getSensedRobots(){
		ArrayList<Robot> robots = new ArrayList<>();
		for (Node node : this.getSensedNodes()){
			if(node instanceof Robot)
			robots.add((Robot)node);
		}
		sensedRobots = robots;
		return robots;
	}
}

class FullVisRobot extends Robot{
	
	    
        //default constructor
       	public FullVisRobot()
       	{
       		
       	}
	
		//Created by Jiaqi Xu
		//Robot constructor
		public FullVisRobot(Point2D currentLocation)
		{
			   this.sensingRange = Double.POSITIVE_INFINITY; 
			  //it is important to  disable wireless for robot
		       this.disableWireless();
		       this.color=Color.red;
		       this.size=10;
		       this.setLocation(currentLocation.getX(),currentLocation.getY());
		}
	
	
	public void move(Destination dest){
		this.dest = (Destination2D)dest;
		setDirection(((Destination2D)dest).dest);
		move(this.distance(this.dest));
	}


	public SnapShot look(){
	//	SnapShot snap = new SnapShot(this.getSensedRobots());
		SnapShot snap = new SnapShot();
		snap.getSnapShot(this);
		return snap;
	}

	public Destination compute(SnapShot snap){
		Destination2D dest = new Destination2D();
		return dest;
	}

}


